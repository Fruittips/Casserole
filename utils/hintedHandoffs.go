package main

// still empty

// TODO1: instantiate map[int] []AtomicDbMessage where int is node id
// TODO2: Write into existing atomic db
// TODO3: Read from atomic db to send when "other" node is back alive
// ensure procedures are atomic

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"time"
)

type AtomicDbMessage struct {
	// Id        int       `json: "id"` // parent node
	Data      []string `json: "Data"`
	Timestamp int64    `json: "Timestamp"`
}

type Handoff struct {
	TableName string                     `json: "TableName"`
	Columns   []string                   `json: "Columns"`
	Row       map[string]AtomicDbMessage `json: "Row"`
}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func initHintedHandoff(nodeid int) {

	initJson := []byte(`{
	"tableName": "hinted handoffs",
	"columns":["course_name", "num_of_slots"],
	"row": [
	]
}`)

	filename := fmt.Sprintf("./hintedHandoffs/node-%d.json", nodeid)
	err := os.WriteFile(filename, initJson, 0644)
	check(err)
}

func readfromHintedHandoff(nodeid int) Handoff {
	var nodeHandoff Handoff
	// use err to determine if there is an existing json file
	filename := fmt.Sprintf("hintedHandoffs/node-%d.json", nodeid)

	_, err := os.Stat(filename)
	if os.IsNotExist(err) {
		initHintedHandoff(nodeid) // if no exisiting file, create a file
	}

	// parse ogData
	byteValue, err := os.ReadFile(filename)
	check(err)
	_ = json.Unmarshal([]byte(byteValue), &nodeHandoff)

	// fmt.Println("col print: ", nodeHandoff.Columns)
	// fmt.Println("col print: ", atomicDbMsgs["0532"])
	return nodeHandoff

}

func getHandoffForRevivedNode(nodeid int, revivedId int) AtomicDbMessage {
	// get hint from hintedHandoff from this node
	allHints := readfromHintedHandoff(nodeid) //type handoff
	strRevivedId := fmt.Sprintf("%d", revivedId)
	hint := allHints.Row[strRevivedId]

	// delete hint that has been gotten
	delete(allHints.Row, strRevivedId)

	fmt.Printf("hint %#v", hint)
	return hint
}

func writeToHintedHandoff(nodeid int, deadNodeId int, data AtomicDbMessage) bool {
	allHints := readfromHintedHandoff(nodeid) //type handoff

	// if there is nothing in the handoff at the moment
	if allHints.Row == nil {
		allHints.Row = make(map[string]AtomicDbMessage)
	}

	// Add the data into the struct
	strDeadNodeId := fmt.Sprintf("%d", deadNodeId)
	allHints.Row[strDeadNodeId] = data

	// convert struct into bytes
	byteFile, err := json.MarshalIndent(allHints, "", "\t")
	if err != nil {
		return false
	}

	// write byte into file
	filename := fmt.Sprintf("hintedHandoffs/node-%d.json", nodeid)
	err2 := os.WriteFile(filename, byteFile, 0644)
	check(err2)

	return true
}

func main() {

	// // INIT TEST //
	// fmt.Println("initHandoff")
	// nodeid := 2
	// go initHintedHandoff(nodeid)
	// time.Sleep(time.Millisecond * 3000)
	// // WRITE ASSERT LATER //

	// READ TEST //
	bytefile := []byte{0x7b, 0xa, 0x9, 0x22, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x20, 0x22, 0x68, 0x69, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6f, 0x66, 0x66, 0x73, 0x22, 0x2c, 0xa, 0x9, 0x22, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x22, 0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x22, 0x63, 0x6f, 0x75, 0x72, 0x73, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x22, 0x6e, 0x75, 0x6d, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x6c, 0x6f, 0x74, 0x73, 0x22, 0xa, 0x9, 0x5d, 0x2c, 0xa, 0x9, 0x22, 0x52, 0x6f, 0x77, 0x22, 0x3a, 0x20, 0x7b, 0xa, 0x9, 0x9, 0x22, 0x30, 0x35, 0x31, 0x36, 0x22, 0x3a, 0x20, 0x7b, 0xa, 0x9, 0x9, 0x9, 0x22, 0x44, 0x61, 0x74, 0x61, 0x22, 0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x44, 0x53, 0x43, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x36, 0x33, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x32, 0x37, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x4f, 0x64, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x67, 0x72, 0x39, 0x22, 0xa, 0x9, 0x9, 0x9, 0x5d, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x22, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x20, 0x31, 0x36, 0x33, 0x37, 0x39, 0x35, 0x33, 0x37, 0x31, 0x36, 0xa, 0x9, 0x9, 0x7d, 0x2c, 0xa, 0x9, 0x9, 0x22, 0x37, 0x37, 0x36, 0x35, 0x22, 0x3a, 0x20, 0x7b, 0xa, 0x9, 0x9, 0x9, 0x22, 0x44, 0x61, 0x74, 0x61, 0x22, 0x3a, 0x20, 0x5b, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x45, 0x53, 0x43, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x36, 0x33, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x39, 0x30, 0x22, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x9, 0x22, 0x4f, 0x64, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 0x74, 0x69, 0x65, 0x22, 0xa, 0x9, 0x9, 0x9, 0x5d, 0x2c, 0xa, 0x9, 0x9, 0x9, 0x22, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3a, 0x20, 0x31, 0x36, 0x39, 0x37, 0x39, 0x35, 0x33, 0x37, 0x31, 0x36, 0xa, 0x9, 0x9, 0x7d, 0xa, 0x9, 0x7d, 0xa, 0x7d}
	nodeHandoff := readfromHintedHandoff(1)
	test1store, _ := json.MarshalIndent(nodeHandoff, "", "\t")
	if bytes.Equal(bytefile, test1store) {
		fmt.Println("Test 1 pass")
	}

	// getHandoffForRevivedNode(1, 7765)

	// WRITE TEST //
	sampleData := AtomicDbMessage{[]string{"Mathematics", "900"}, time.Now().Unix()}
	_ = writeToHintedHandoff(2, 0532, sampleData)

}
